<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<title>Mini GTA 5 Top-Down</title>
<style>
body { margin: 0; overflow: hidden; background: #111; font-family: sans-serif; }
canvas { display: block; margin: 0 auto; background: #2c3e50; border: 2px solid #fff; }
#score { position: absolute; top: 10px; left: 50%; transform: translateX(-50%); color: #fff; font-size: 24px; text-shadow: 2px 2px 5px black;}
#minimap { position: absolute; top: 10px; right: 10px; border: 2px solid #fff; background: rgba(0,0,0,0.5);}
</style>
</head>
<body>
<div id="score">Score: 0</div>
<canvas id="gameCanvas" width="1000" height="600"></canvas>
<canvas id="minimap" width="200" height="120"></canvas>

<script>
const canvas = document.getElementById('gameCanvas');
const ctx = canvas.getContext('2d');
const minimap = document.getElementById('minimap');
const miniCtx = minimap.getContext('2d');

const mapWidth = 3000;
const mapHeight = 2000;

let keys = {};
let bullets = [];
let enemies = [];
let score = 0;

// Player car
let player = {
  x: mapWidth/2,
  y: mapHeight/2,
  width: 50,
  height: 80,
  speed: 0,
  angle: 0,
  maxSpeed: 6
};

// Buildings
const buildings = [];
for(let i=0;i<50;i++){
  buildings.push({x: Math.random()*mapWidth, y: Math.random()*mapHeight, width: 120, height: 80});
}

// Enemy cars
function spawnEnemy(){
  let x = Math.random()*mapWidth;
  let y = Math.random()*mapHeight;
  enemies.push({x:x, y:y, width:50, height:80, speed:2 + Math.random()*2, angle:0});
}

// Controls
document.addEventListener('keydown', e => keys[e.key.toLowerCase()] = true);
document.addEventListener('keyup', e => keys[e.key.toLowerCase()] = false);

// Shooting
document.addEventListener('keydown', e=>{
  if(e.key===' ') bullets.push({
    x: player.x + player.width/2 - 5,
    y: player.y - 10,
    width: 10,
    height: 20,
    speed: 12
  });
});

// Collision
function checkCollision(a,b){
  return a.x < b.x + b.width && a.x + a.width > b.x &&
         a.y < b.y + b.height && a.y + a.height > b.y;
}

// Camera
let camera = {x:0, y:0, width: canvas.width, height: canvas.height};

function update(){
  // Player movement
  if(keys['w']) player.speed = Math.min(player.speed+0.2, player.maxSpeed);
  else if(keys['s']) player.speed = Math.max(player.speed-0.2, -player.maxSpeed/2);
  else player.speed *= 0.95;

  if(keys['a']) player.angle -= 0.05;
  if(keys['d']) player.angle += 0.05;

  player.x += Math.sin(player.angle)*player.speed;
  player.y -= Math.cos(player.angle)*player.speed;

  // Keep inside map
  player.x = Math.max(0, Math.min(player.x, mapWidth - player.width));
  player.y = Math.max(0, Math.min(player.y, mapHeight - player.height));

  // Camera
  camera.x = player.x + player.width/2 - canvas.width/2;
  camera.y = player.y + player.height/2 - canvas.height/2;
  camera.x = Math.max(0, Math.min(camera.x, mapWidth - canvas.width));
  camera.y = Math.max(0, Math.min(camera.y, mapHeight - canvas.height));

  // Clear canvas
  ctx.clearRect(0,0,canvas.width,canvas.height);

  // Map background
  ctx.fillStyle = '#34495e';
  ctx.fillRect(-camera.x, -camera.y, mapWidth, mapHeight);

  // Draw buildings
  ctx.fillStyle = '#7f8c8d';
  buildings.forEach(b => ctx.fillRect(b.x - camera.x, b.y - camera.y, b.width, b.height));

  // Draw player car
  ctx.save();
  ctx.translate(player.x - camera.x + player.width/2, player.y - camera.y + player.height/2);
  ctx.rotate(player.angle);
  ctx.fillStyle = '#e74c3c';
  ctx.fillRect(-player.width/2, -player.height/2, player.width, player.height);
  ctx.restore();

  // Bullets
  bullets.forEach((b,i)=>{
    b.y -= b.speed;
    ctx.fillStyle = '#f1c40f';
    ctx.fillRect(b.x - camera.x, b.y - camera.y, b.width, b.height);
    if(b.y < 0) bullets.splice(i,1);
  });

  // Spawn enemies
  if(Math.random() < 0.01) spawnEnemy();

  // Enemy movement
  enemies.forEach((e,i)=>{
    // Move towards player
    let dx = player.x - e.x;
    let dy = player.y - e.y;
    let dist = Math.sqrt(dx*dx + dy*dy);
    e.x += (dx/dist)*e.speed;
    e.y += (dy/dist)*e.speed;

    // Draw enemy
    ctx.save();
    ctx.translate(e.x - camera.x + e.width/2, e.y - camera.y + e.height/2);
    ctx.rotate(e.angle);
    ctx.fillStyle = '#3498db';
    ctx.fillRect(-e.width/2, -e.height/2, e.width, e.height);
    ctx.restore();

    // Collision with player
    if(checkCollision(player,e)){
      alert('Game Over! Final Score: '+score);
      location.reload();
    }

    // Collision with bullets
    bullets.forEach((b,j)=>{
      if(checkCollision(b,e)){
        bullets.splice(j,1);
        enemies.splice(i,1);
        score += 10;
        document.getElementById('score').innerText = `Score: ${score}`;
      }
    });
  });

  // Draw minimap
  miniCtx.clearRect(0,0,minimap.width,minimap.height);
  miniCtx.fillStyle = '#34495e';
  miniCtx.fillRect(0,0,minimap.width,minimap.height);
  buildings.forEach(b=>{
    miniCtx.fillStyle = '#7f8c8d';
    miniCtx.fillRect(b.x/mapWidth*minimap.width, b.y/mapHeight*minimap.height, b.width/mapWidth*minimap.width, b.height/mapHeight*minimap.height);
  });
  miniCtx.fillStyle = '#e74c3c';
  miniCtx.fillRect(player.x/mapWidth*minimap.width, player.y/mapHeight*minimap.height, player.width/mapWidth*minimap.width, player.height/mapHeight*minimap.height);

  requestAnimationFrame(update);
}

update();
</script>
</body>
</html>
